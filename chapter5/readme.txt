典型的一次IO的两个阶段： 数据就绪和数据读写
阻塞/非阻塞
    阶段一：数据准备（就绪）
        - 阻塞：数据未到达之前，IO操作函数会一直等待数据，线程挂起(不占用资源)，不执行后续代码
        - 非阻塞：数据未到达之前，IO操作不会一直等待，也不会改变线程的状态，通过返回值判断
        典型操作函数：read/recv
            ssize_t recv(int sockfd, void *buf, size_t len, int flags);
            阻塞模式：sockfd对应系统中的TCP接收缓冲区，如果缓冲区内有数据写入，则recv解除阻塞状态
            非阻塞模式：即使没有数据写入，也不阻塞在这里，可以继续执行程序
        - 可以改变flags值来设置阻塞/非阻塞
        - 可以通过读取return value来判断通信的状态
            ret == -1 错误（EINTR/EAGAIN/EWOULDBLOCK属于正常错误，非系统错误）
            ret == 0 表示读取到数据的末尾，对方连接关闭了
            ret > 0 表示读取到了多少数据

同步/异步
    阶段二：数据读写
        - 同步：用户进程自成一体
            char buf[1024] = {0};
            ssize_t recv(int sockfd, void *buf, size_t len, int flags);
            应用层由用户自行读写
            在函数工作过程中，程序是不可以继续进行的
            只有buf全部读满才可以继续执行程序

        - 异步：用户进程和系统操作各走各的
            效率比同步更高
            同时代码也更复杂
            需要操作系统使用IO接口来判断socket状态
                异步IO接口包含的信息（sockfd buf 通知方式）
                    通知方式：sigio信号
            读写操作交给系统后，程序可以继续运行
            当系统收到数据后会通知进程，buf中的数据准备好了，可以直接使用

    - 在处理IO的时候，阻塞和非阻塞都是同步IO，只有使用了特殊的API才是异步IO
    - IO多路复用（select poll epoll）都是同步的

五种IO模型
    1. 阻塞 blocking
        调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停地检查这个函数有没有返回
        必须等这个函数返回才能进行下一步动作
        - 阻塞不是函数的行为，而是文件描述符（fd, socket）的属性

    2. 非阻塞 non-blocking
        非阻塞等待，每隔一段时间就去检测IO事件是否就绪，没有就绪就可以做其他事
        非阻塞IO执行系统调用总是立即返回，不管事件有没有发生
        需要自己通过返回值来选择后续如何处理

    3. IO复用 IO multiplexing
        linux用select/epoll/poll函数实现IO复用模型，这些函数也会使进程阻塞，但是可以同时进行多个
            IO操作，即一个fd阻塞的时候可以检测其他fd有没有数据修改（事件发生）
        直到有数据可读或可写时，才真正调用IO函数

    4. 信号驱动 signal-driven
        linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞
        当IO事件就绪，进程收到SIGIO信号，然后处理IO事件
        - 内核在第一个阶段（等待信号）是异步，第二个阶段（处理IO事件）是同步

    5. 异步IO
        linux中通过调用aio_read函数告诉内核描述缓冲区指针和缓冲区大小，文件偏移及通知的方式
            然后立即返回，当<内核>将数据拷贝到缓冲区后，再通知应用程序；

Web Server 网页服务器介绍
    一个Web Server就是一个服务器软件(程序)，或者是运行这个服务器软件的硬件(计算机)
    功能：通过HTTP协议与客户端(通常是浏览器Browser)进行通信，来接收，存储，处理来自客户端的
        http请求，并对其请求做出HTTP响应，返回给客户端其请求的内容(文件、网页等)或返回一个Error信息。
    
    通常用户通过 Web 浏览器和服务器进行通信
        在浏览器中键入域名或IP地址：端口号，浏览器则先将域名解析成相应的IP地址或直接根据
        你的IP地址向对应的Web服务器发送一个HTTP请求。这一过程首先要通过TCP协议的三次握手建立
        与目标Web服务器的连接，然后HTTP协议生成针对目标 Web 服务器的HTTP请求报文，通过TCP、IP等协议发送
        到目标Web服务器上。

HTTP协议 <应用层协议>
    超文本传输协议：不止能传输文本，图像、音频都可以。
    - 一个简单的请求-响应协议，通常基于TCP运行（传输）
    - HTTP报文包含了客户端可能发送给服务器什么样的消息以及得到什么样的相应
    - HTTP是万维网的数据通信的基础
    
    工作原理：
        - HTTP协议定义Web客户端如何从服务器请求Web界面，以及服务器如何把Web页面传送给客户端
        - 请求相应的步骤：
            1. 客户端连接到web服务器
                一个http客户端，通常是浏览器，与web服务器的http端口建立一个tcp套接字连接

            2. 发送http请求
                通过tcp套接字客户端向web服务器发送一个文本的请求报文

            3. 服务器接受请求并返回HTTP响应
                服务器解析请求，定位请求资源，服务器将资源复本写到tcp套接字

            4. 释放连接tcp连接
                connection为close：服务器主动关闭tcp连接，客户端被动关闭
                connection为keepalive：该连接会保持一段时间，在该时间内可以继续接受请求

            5. 客户端浏览器解析HTML内容
                客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码，然后解析每一个响应头，响应头
                告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其
                进行格式化，并在浏览器窗口中显示。
        
        - 在浏览器地址栏键入URL，按下回车后会经历的流程：
            1. 浏览器向DNS服务器请求解析该URL中的域名对应的IP地址
            2. 根据解析出的IP地址和默认端口80和服务器建立TCP连接
            3. 浏览器发出读取文件(URL中域名后面部分对应的文件)的http请求，该请求报文作为TCP三次握手的
                第三个报文的数据发送给服务器。
            4. 服务器对浏览器请求作出响应，并把对应的HTML文本发送给浏览器
            5. 释放连接tcp连接
            6. 浏览器将该HTML文本内容映射到浏览器中
        
        HTTP 请求报文格式
            状态行：请求方法 + URL + 协议版本（中间都有空格符，每一行最后有回车符和换行符）
            请求头部：头部字段名 +　值（键值对形式）　
            请求数据
            GET / HTTP/1.1
            Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
            Accept-Encoding: gzip, deflate, br
            Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
            Cache-Control: max-age=0
            Connection: keep-alive

        HTTP 响应报文格式
            状态行：协议版本 + 状态码 +　状态码描述
            响应头部：头部字段名　＋　值
            响应正文
            HTTP/1.1 200 OK
            Bdpagetype: 2
            Bdqid: 0xd6abca5f00040a11
            Connection: keep-alive
            Content-Encoding: gzip
            Content-Type: text/html; charset=utf-8
            Date: Mon, 06 Mar 2023 12:26:21 GMT
            Isprivate: 1
            Server: BWS/1.1

服务器编程基本框架
    服务器程序种类繁多，但基本框架一样，不同之处在于逻辑处理
    模块：
        I/O处理单元    - 处理客户连接、读写网络数据
        逻辑单元       - 业务进程或线程
        网络存储单元   - 数据库、文件或缓存
        请求队列       - 各单元之间的通信方式
    
    (NGIX服务器 后续可以学习、扩展)

两种高效的事件处理模式
    服务器程序通常需要处理三类事件：IO事件、信号及定时事件。
    两种高效的事件处理模式：Reactor和Proactor
    同步IO模型通常用于实现Reactor模式
    异步IO模型通常用于实现Proactor模式

    Reactor模式
        要求主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生
        有的话就立即将该事件通知工作线程(逻辑单元)，将socket可读可写事件放入请求队列
        交给工作线程处理。除此之外主线程不做任何其他实质性的工作。
        <接受新的连接>、处理客户请求均在工作线程中完成

        使用同步I/O(以epoll_wait为例)实现的Reactor模式的工作流程：
            1. 主线程往epoll内核事件表中注册socket上的读就绪事件
            2. 主线程调用epoll_wait等待socket上有数据可读
            3. 当socket上有数据可读时，epoll_wait通知主线程，主线程将socket可读事件放入请求队列
            4. 睡眠在请求队列上的某个工作线程将被唤醒，它从socket读取数据，并处理客户请求，
                然后往epoll内核事件表中注册该socket上的写就绪事件
            5. 主线程调用epoll_wait等待socket可写
            6. 当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列
            7. 睡眠在请求队列上的某个工作线程被唤醒，往socket上写入服务器处理客户请求的结果。

    Proactor模式
        将所有IO操作都交给主线程和内核来处理(进行读写)，工作线程仅仅负责业务逻辑，使用异步IO模型实现的Proactor
        模式的工作流程：
            1. 主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，
                以及读操作完成时如何通知应用程序（这里以信号为例）。
            2. 主线程继续处理其他逻辑。
            3. 当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据
                已经可用。
            4. 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求
                后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以
                及写操作完成时如何通知应用程序。
            5. 主线程继续处理其他逻辑。
            6. 当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据
                已经发送完毕。
            7. 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。

线程池
    线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和CPU数量差不多
    线程池中所有子线程都运行着相同的代码，当有新的任务到达时，主线程将通过某种方式选择
    线程池中的某一个子线程为之服务。相比动态创建子线程，选择一个已经存在的子线程的代价小得多
    主线程如何选择子线程来为新任务服务：
        - 主线程使用某种算法来主动选择子线程：随机算法、RR(轮流选取)算法
        - 主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。
            当有新的任务到达时，主线程将任务添加到工作队列中，唤醒正在等待任务的子线程
            只有一个子线程将获得任务的接管权，它可以从工作队列中取出任务并执行，其他子线程
            继续睡眠在工作队列上
    
    线程池的特点
        - 空间换事件，浪费服务器的硬件资源，换取运行效率
        - 池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，称为静态资源
        - 当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接
            从线程池中获取，无需动态分配
        - 当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源
